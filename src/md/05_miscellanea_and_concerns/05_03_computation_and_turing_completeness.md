## محاسبه و تورینگ‌کامل‌بودن

(Computation And Turing-Completeness)

نکتهٔ مهم این است که ماشین مجازی اتریوم (Ethereum Virtual Machine یا EVM) **تورینگ‌کامل** (Turing-complete) است؛ به این معنا که کدهای EVM می‌توانند هر محاسبه‌ای را که از نظر نظری قابل انجام است پیاده‌سازی کنند، از جمله حلقه‌های بی‌نهایت. کد EVM امکان ایجاد حلقه را به دو روش فراهم می‌کند. نخست، از طریق دستور `JUMP` که اجازه می‌دهد برنامه به نقطه‌ای قبلی در کد بازگردد، و دستور `JUMPI` برای پرش شرطی، که امکان ساخت عباراتی مانند `while x < 27: x = x * 2` را فراهم می‌کند. دوم، قراردادها می‌توانند قراردادهای دیگر را فراخوانی کنند که این موضوع امکان ایجاد حلقه از طریق بازگشت (recursion) را فراهم می‌سازد.

این قابلیت به‌طور طبیعی یک مشکل ایجاد می‌کند: آیا کاربران مخرب می‌توانند با وادارکردن استخراج‌کنندگان و گره‌های کامل به ورود به یک حلقهٔ بی‌نهایت، عملاً شبکه را از کار بیندازند؟ این مسئله ناشی از مشکلی شناخته‌شده در علوم کامپیوتر است که «مسئلهٔ توقف» (Halting Problem) نام دارد؛ یعنی به‌طور کلی هیچ راهی وجود ندارد که بتوان از پیش تعیین کرد آیا یک برنامه در نهایت متوقف خواهد شد یا خیر.

همان‌طور که در بخش تابع انتقال وضعیت توضیح داده شد، راه‌حل اتریوم این است که هر تراکنش باید حداکثر تعداد گام‌های محاسباتی مجاز خود را مشخص کند. اگر اجرای کد از این حد فراتر رود، محاسبه بازگردانده می‌شود، اما کارمزد همچنان پرداخت خواهد شد. پیام‌ها نیز دقیقاً به همین شیوه عمل می‌کنند. برای درک بهتر انگیزهٔ این راه‌حل، مثال‌های زیر را در نظر بگیرید:

- یک مهاجم قراردادی ایجاد می‌کند که یک حلقهٔ بی‌نهایت اجرا می‌کند و سپس تراکنشی برای فعال‌سازی آن به استخراج‌کننده ارسال می‌کند. استخراج‌کننده تراکنش را پردازش کرده و حلقهٔ بی‌نهایت را اجرا می‌کند تا زمانی که گس تمام شود. با وجود آن‌که اجرا در میانهٔ کار متوقف می‌شود، تراکنش همچنان معتبر است و استخراج‌کننده کارمزد هر گام محاسباتی را از مهاجم دریافت می‌کند.

- یک مهاجم حلقه‌ای بسیار طولانی ایجاد می‌کند تا استخراج‌کننده را وادار کند آن‌قدر محاسبه انجام دهد که تا پایان اجرا چند بلاک جدید استخراج شود و دیگر امکان گنجاندن تراکنش در بلاک برای دریافت کارمزد وجود نداشته باشد. با این حال، مهاجم مجبور است مقدار `STARTGAS` را از پیش مشخص کند و این مقدار سقف تعداد گام‌های محاسباتی را تعیین می‌کند؛ بنابراین استخراج‌کننده از ابتدا می‌داند که اجرای این تراکنش چه‌قدر سنگین خواهد بود.

- یک مهاجم قراردادی با کدی از این جنس مشاهده می‌کند:  
  `send(A, contract.storage[A]); contract.storage[A] = 0`  
  سپس تراکنشی ارسال می‌کند که فقط به‌اندازهٔ اجرای دستور اول گس دارد، اما برای اجرای دستور دوم کافی نیست (یعنی برداشت انجام می‌شود، اما موجودی صفر نمی‌شود). نویسندهٔ قرارداد نیازی به محافظت خاص در برابر این نوع حمله ندارد، زیرا اگر اجرا در میانهٔ راه متوقف شود، تمام تغییرات بازگردانده می‌شوند.

- یک قرارداد مالی برای کاهش ریسک، مقدار میانهٔ ۹ منبع دادهٔ اختصاصی را محاسبه می‌کند. مهاجم کنترل یکی از این منابع داده را که از طریق سازوکار فراخوانی با آدرس متغیر (توضیح‌داده‌شده در بخش DAOها) قابل تغییر است، به‌دست می‌گیرد و آن را به یک حلقهٔ بی‌نهایت تبدیل می‌کند تا تمام تلاش‌ها برای برداشت وجه از قرارداد مالی با اتمام گس مواجه شود. با این حال، قرارداد مالی می‌تواند برای پیام ارسالی یک محدودیت گس تعیین کند و از این مشکل جلوگیری نماید.

جایگزین تورینگ‌کامل‌بودن، **تورینگ‌ناقص‌بودن** (Turing-incompleteness) است؛ حالتی که در آن دستورهای `JUMP` و `JUMPI` وجود ندارند و در هر لحظه فقط یک نسخه از هر قرارداد می‌تواند در پشتهٔ فراخوانی قرار گیرد. در چنین سیستمی، شاید نیازی به سازوکار کارمزد و عدم‌قطعیت‌های مربوط به اثربخشی راه‌حل فعلی نبود، زیرا هزینهٔ اجرای یک قرارداد به‌طور قطعی توسط اندازهٔ آن محدود می‌شد. افزون بر این، تورینگ‌ناقص‌بودن حتی محدودیت بزرگی هم به‌نظر نمی‌رسد؛ از میان تمام نمونه‌قراردادهایی که تاکنون به‌صورت داخلی بررسی شده‌اند، فقط یکی به حلقه نیاز داشت و حتی آن هم می‌توانست با تکرار ۲۶ بارهٔ یک خط کد جایگزین شود.

با توجه به پیامدهای جدی تورینگ‌کامل‌بودن و مزایای ظاهراً محدود آن، این پرسش مطرح می‌شود: چرا از یک زبان تورینگ‌ناقص استفاده نکنیم؟ اما در عمل، تورینگ‌ناقص‌بودن راه‌حل تمیزی برای این مشکل نیست. برای روشن‌شدن موضوع، قراردادهای زیر را در نظر بگیرید:

```text
C0 → C1 → C2 → ...
C4: call(call(call(C1, C2, C3)));
C9: call(C50); call(C50);
C50: (اجرای یک گام از برنامه و ثبت تغییر در فضای ذخیره‌سازی)
```
